# React- 기초 공부
# 1. react
## 1. react란
### 1. 기존 HTML로 구성된 화면들은 페이지를 이동하건 데이터가 바뀌면 새로운 HTML파일을 불러와서 화면에 표출하는 방식.(MPA: Multi Page Application)
### 2. react는 MPA와는 반대되는 SPA(Single Page Application) 방식으로 HTML 파일은 하나만 사용하고 페이지를 이동하거나 데이터가 변경됐을 때 HTML파일에 있는 태그를 삭제후 새로운 태그를 렌더링하는 방식을 사용.
### 3. react는 HTML, CSS, Javascript의 사용을 편하게 해주고 오직 화면단만 신경쓰는 프론트엔드 라이브러리.
### 4. 그래서 react를 사용하기 앞서 Html, Css, Javascript는 기본적으로 숙지가 되어있어야 한다.

## 2. react 특징
### 1. Virtual DOM(가상 DOM: 가상 HTML 페이지)
    - 페이지를 이동하거나 데이터가 변경됐을 때 HTML파일의 태그들을 바로 삭제하는 것이 아니고 가상 DOM에 이동할 페이지나 데이터가 변경된 부분의 태그만 새로 생성
    - 현재 Html DOM 파일과 가상 DOM을 비교
    - 페이지 이동으로 DOM전체가 변경됐을 때는 현재 Html DOM의 태그를 모두 삭제하고 가상 DOM의 내용을 렌더링
    - 데이터가 변경돼서 현재 DOM에서 어느 부분만 바뀌었을 때는 바뀐 부분 렌더링(자동 비동기 처리)
### 2. react에서는 화면의 특정부분을 정의하는 선언체가 존재하는데 이것을 컴포넌트라고 부른다. 컴포넌트를 조립하여 하나의 화면을 구성하여 표출하는 방식을 사용. 컴포넌트를 사용하면 코드의 재사용성을 높일 수 있는 장점이 있다. .js, .ts, .jsx의 확장자로 컴포넌트를 구성할 수 있다.
### 3. 렌더링이라는 개념이 사용된다. 렌더링은 사용자에게 화면을 표출해주는 메소드. 렌더링은 화면이 처음 표출되는 초기 렌더링과 데이터가 변경될 때 다시 렌더링되는 리렌더링으로 구분.
### 4. 컴포넌트의 상태를 나타내는 상태변수가 존재한다. 상태변수는 크게 부모 컴포넌트로부터 물려받은 props변수와 현재 컴포넌트의 상태를 나타내는 state변수로 나눌 수 있다. props나 state가 값이 변경되면 해당 컴포넌트가 리렌더링 된다.
### 5. 컴포넌트에서도 부모 자식관계가 존재하여 상속관계를 구현할 수 있다. 부모에서 자식으로 넘겨주는 변수들을 props변수라고 하고 props도 마찬가지로 상태변수의 일종으로 값이 변경되면 리렌더링된다.
### 6. 리액트는 모든 메소드가 비동기 처리되어있기 때문에 동기화를 해주는 작업이 필요하다.

# 1. JSX
## 1. JSX란
### 1. JSX란 Javascript의 확장문법으로 XML과 매우 비슷한 구조를 가지고 있다.
### 2. JSX는 브라우저가 실행되기 전에 일반 Javascript 코드로 변환되어 실행
### 3. JSX 코드는 Html 코드를 작성하는 것과 비슷하고 코드가 보기 편하다.

## 2. JSX 문법
### 1. 컴포넌트에 여러가지 태그가 포함되면 항상 태그들을 묶어주는 최상의 태그가 필요하다. react에서는 묶어주는 태그로 <Fragment></Fragment>, <div></div>, <></>(<Fragment></Fragment>의 다른 표현)를 주로 사용한다. 
### 2. Javascript의 변수나 표현식을 사용할 수가 있는데 사용할 때는 {}로 묶어서 표출
### 3. if문 대신 삼항연산자를 사용하여 조건문을 구성해야 한다.
### 4. JSX 문법안의 태그에 인라인 스타일을 줄때는 카멜케이스로 속성을 지정한다. background-color => backgroundColor
### 5. class 대신 className을 사용한다.
### 6. Html에서는 닫는 태그를 생략해도 에러가 발생하지 않지만 JSX에서는 닫는 태그를 생략하면 에러발생한다.
### 7. JSX에서 주석은 {/* */}로 작성한다.

# 1. 컴포넌트
## 1. 컴포넌트란
### 1. 컴포넌트는 react에서 화면을 구성하는 하나의 조각.
### 2. 헤더나 메인, 메뉴바, 기사목록 등등의 화면을 하나의 컴포넌트로 구성할 수 있다. 너무 작은단위로 컴포넌트를 분리하는 작업은 너무 많은 파일을 만들기 때문에 적당한 크기의 컴포넌트를 지정하는 것이 중요하다.
### 3. 컴포넌트에는 클래스형 컴포넌트와 함수형 컴포넌트 두 가지가 존재한다. 현재는 리액트 공식사이트나 공식문서에서도 함수형 컴포넌트를 사용하도록 권장하는 추세다.

## 2. 클래스형 컴포넌트
```
class 컴포넌트명 extends Component {
    render() {
        <div>
        </div>
    }
}
```
### 1. 클래스형 컴포넌트에서는 렌더링 시 render메소드를 사용한다.

## 3. 함수형 컴포넌트
```
function 컴포넌트명() {
    return (
        <div>
        </div>
    );
} 
const 컴포넌트명 = () => {
    return (
        <div>
        </div>
    );
}
```
### 1. 함수형 컴포넌트는 렌더링시 return문을 사용한다.
### 2. 클래스형 컴포넌트와 함수형 컴포넌트의 성능은 비슷하지만 함수형 컴포넌트 메모리를 적게 사용하기 때문에 함수형 컴포넌트의 사용이 권장되고 있다.

## 3. props
### 1. props는 컴포넌트의 상태 값 중 하나. 부모로부터 상속받는 값으로 상속 시 속성으로 지정되어 상속받기 때문에 속성값이라고도 한다.
```
fucnction Children(num) {
    return (
        <div>
        자식 컴포넌트
        </div>
    );
}

function Parent() {
    let num = 0;
    return {
        <Children num={num}></Children>
    }
}
```
### 2. props의 값은 부모컴포넌트에서 지정할 수 있고 자식에서 변경하려면 부모의 메소드를 상속받아서 부모의 메소드를 호출해야 한다.
### 3. props를 받는 방식은 두 가지가 있다. props 변수로 넘어오는 값들을 한 번에 받는 방식과 비구조할당으로 넘어오는 값들을 각각 받아주는 방식이 있다.
### 4. props로 부모에 있는 메소드도 넘겨 줄 수 있다.

## 4. state
### 1. state는 props와 마찬가지로 컴포넌트의 상태변수중 하나.
### 2. state의 값이 변하면 해당 컴포넌트가 리렌더링 된다.
### 3. 함수형 컴포넌트에서는 Hooks라는 기능들을 이용하게 되는데 state변수를 만드는 것도 Hooks의 기능중 하나. useState()메소드를 이용해서 state 변수를 생성.
### 4. useState()의 매개변수로는 state의 초기값을 넣어줄 수가 있는데 string, number, array 타입 등 모든 javascript의 타입을 사용할 수 있다.
### 5. state는 항상 변수와 setter메소드를 쌍으로 만들어준다.
```
//state의 선언
const [state변수명, setter메소드] = useState(state 변수의 초기값);
```
### 6. 부모의 state를 props로 자식으로 보내줄 수 있다. 그리고 부모의 state를 자식에서 변경하고 싶을 때는 setter메소드를 호출하는 메소드를 부모컴포넌트에 만들어서 해당 메소드를 자식 컴포넌트에 props로 넘겨서 메소드를 호출하여 부모 컴포넌트의 state의 값을 변경한다.

## 5. 이벤트 핸들링
### 1. react에서 이벤트를 매핑할 때는 카멜케이스 표기법사용(onclick => onClick, onkeydown => onKeyDown)
### 2. 이벤트에서 실행할 내용은 대부분 메소드형태로 전달한다. 이벤트를 매핑할 때 직접 메소드를 화살표함수 형태로 전달해도 되고 외부에 메소드를 선언한 다음 매핑해줘도 된다.
### 3. DOM 요소인 Html 태그에만 이벤트를 등록할 수 있고 컴포넌트에는 이벤트 등록이 불가능하다. 컴포넌트에 onClick을 만들어주면 props로 인식한다.

# 1. Hooks
## 1. Hooks란
### 1. 기존 react에서는 클래스형 컴포넌트로 개발이 주로 이뤄졌다.  함수형 컴포넌트에는 state, props, ref 등의 생명주기를 관리할 수 있는 기능이 없었다.
### 2. Hooks라는 기능이 등장하면서 함수형 컴포넌트에서도 state, props, ref 등의 생명주기를 관리할 수 있는 기능이 추가되면서 현재는 대부분 함수형 컴포넌트 위주의 개발이 이뤄진다.
### 3. Hooks는 컴포넌트의 상태관리 변수를 생성하는 useState, 렌더링 직후의 동작을 지정할 수 있는 useEffect 등과 같은 기능을 제공해주는 라이브러리

## 2. useEffect
### 1. 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 할 수 있는 Hook
### 2. 처음 렌더링될 때와 리렌더링될 때 지정된 작업을 수행
```
useEffect(() => {
    //렌더링 시 실행될 작업
}, []//어떤 상태값의 변화에 따라 작업을 실행할 것인지 빈칸이면 초기 렌더링시에 작업 실행);
```
### 3. react는 거의 대부분 비동기로 동작하는 데 동작하는 시점을 동기화하여 맞춰줄 때 주로 사용한다.
### 4. useEffect에서 cleanup메소드를 리턴하면 state 값이 변경되기 직전에 실행될 내용을 작성할 수 있다.
```
useEffect(() => {
    return () => {
        //cleanup 메소드
        //state 값이 변경되기 전에 실행될 내용 작성
    }
}, [state]);
```

## 3. useReducer
### 1. 컴포넌의 상황에 따라 state 값을 다른 값으로 업데이트하고 싶을 때 사용하는 Hook
### 2. useReducer는 현재 state 값과 업데이트를 위해 필요한 정보를 담고 있는 액션을 매개변수로 받아서 사용한다.
```
function reducer(state, action) {
    //action의 타입에 따라서 실행될 내용 작성
}

const [state, dispatch] = useReducer(reducer, {
    state의 초기값
});
```
### 3. dispatch는 action을 실행시키는 메소드. dispatch(action) => action을 발생시키면서 reducer로 지정된 메소드를 호출한다.
### 4. reducer로 지정될 메소드는 컴포넌트 밖에 선언한다.

## 4. useCallback
### 1. useCallback은 렌더링 성능을 최적화할 때 사용하는 Hook
### 2. 컴포넌트에 정의해놓은 메소드들은 렌더링될 때마다 재성성되는 데 useCallback을 이용하면 메소드들이 재생성되는 것을 방지
### 3. useCallback 정의해놓은 메소드의 재사용성을 높일 수 있고 메소드가 생성되는 시점을 지정할 수 있다.
```
const 메소드명 = useCallback(() => {
    //메소드의 동작 구현
}, [] //최초 렌더링 시에만 메소드 생성, 상태변수 값을 줘서 상태변수가 변할 때마다 메소드를 재생성);
```

## 5. useMemo
### 1. useMemo는 연산을 최적화해주는 Hook
### 2. 상태값이 변할 때만 연산이 이뤄지도록 지정할 수 있어서 불필요한 연산이 일어나는 것을 방지할 수 있다.
```
useMemo(() => {
    //상태변수의 값이 변했을 때 일어날 연산 
}, [상태변수]);

useMemo(() => 미리 정의해놓은 연산메소드(), [상태변수]);
```

## 6. useRef
### 1. Html에서는 DOM 태그의 식별자로 id를 주로 사용했었는데 react에서는 id대신 ref를 사용.
### 2. react에서 동일한 컴포넌트를 여러번 사용했을 때 id의 유일성이 파괴되기 때문에 id를 식별자로 사용할 수 없다.
### 3. JSX는 ref를 이용해서 같은 컴포넌트가 여러번 사용되어도 유일한 ref값을 지정할 수 있다.
### 4. 유일한 ref값을 만들어주는 Hook이 useRef
```
const 변수명 = useRef();

//유일한 ref값을 갖는 DOM태그
<input ref={변수명}>
```
### 5. useRef 이용 시 선택자 없이도 해당 DOM에 접근할 수 있다.

# 1. Component Styling
## 1. Component Styling(컴포넌트 스타일)
### 1. 일반적으로 컴포넌트에 스타일을 입히는 방식은 4가지 방식을 주로 이용한다.
### 2. 일반적인 CSS 방식(외부 스타일 시트, 내부 스타일 시트, 인라인 스타일 시트)를 사용하는 방식, SASS(Syntanctically Awesome Style Sheet) 방식, CSS 모듈 방식, styled-component 방식을 주로 사용.

## 2. 일반적인 CSS 방식
### 1. 일반적인 CSS 방식은 Html 문서에서 사용하는 Css방식과 동일한 방식으로 외부에 Css파일을 만들어서 참조하거나 인라인 스타일을 지정하거나 변수로 스타일을 지정해서 넘길 수도 있다.

## 3. SASS 방식
### 1. Css 전처리기가 복잡한 스타일 시트 작업을 쉽게 처리해주고 스타일 코드의 재상용성을 높여준다. 코드의 가독성이 일반적인 Css방식보다 좋다.
### 2. SASS 방식은 확장자가 .sass, .scss인 파일을 지원한다.
### 3. Css, Sass, Scss 모두 조금씩 문법이 다르다.
### 4. sass 설치: 터미널에서 npm install sass 입력(각 프로젝트별로 별도 진행)

## 4. Css 모듈 방식
### 1. Css 파일을 불어와서 클래스를 지정할 때 클래스 이름을 고유한 값으로 지정해주는 방식.
### 2. [파일명]_[클래스명]_[해시값]의 형태로 클래스 이름을 지정해준다.
### 3. 클래스명을 유일하게 해주고 클래스명의 중첩을 방지할 수 있으며 스타일 동일하게 사용할 수 있다.
### 4. Css 모듈로 사용할 파일의 파일명은 파일명.module.css로 지정한다.

## 5. Styled-Component 방식
### 1. styled-components 라이브러리에서 제공하는 기능으로 백틱(`)을 이용해서 태그와 스타일까지 한 번에 정의된 컴포넌트를 생성해준다.
### 2. 태그와 스타일까지 한 번에 지정하는 탬플릿 리터럴을 tagged 탬플릿 리터럴이라고 한다.
### 3. styled-components 설치: npm install styled-components 입력(각 프로젝트 별로 별도 진행)

# 1. Immersion(불변성)
## 1. 불변성이란
### 1. 불변성이라는 것은 원본데이터의 변경을 금지하는 것을 뜻한다. react에서는 불변성을 지키기위해 기존 원본데이터를 직접 수정하지 않고 새로운 데이터를 만들어서 사용한다.
```
const numArr = [1, 2, 3, 4, 5];
//스프레드 문법을 통한 새로운 배열 생성
const newNumArr = [...numArr];

const obj = {
    num1: 1,
    num2: 2,
    num3: 3
};

const newObj = {
    ...obj
};

const newObj2 = {
    num3: 5,
    ...obj
}
```
### 2. 만약 객체의 구조가 복잡해지면 불변성을 유지하는 것이 쉽지 않다.
```
const complexObj = {
    id: 1,
    name: 'a',
    objInside: {
        number: 1,
        checked: true
    }
};

const newComplexObj = {
    ...complexObj,
    name: 'b',
    objInside: {
        ...complexObj.objInside,
        checked: false
    }
}
```
### 3. 불변성을 유지하기 힘든 구조의 객체는 immer 라이브러리를 사용해서 불변성 유지한다.
### 4. immer 라이브러리를 사용하면 불변성을 신경쓰지 않는 것처럼 코드를 작성하지만 코드의 불변성 관리는 제대로 이뤄진다.
### 5. immer 라이브러리 설치: npm install immer 입력

# 1. react의 router
## 1. 라우팅이란
### 1. 웹 어플리케이션에서 사용자 요청에 따라 알맞는 페이지를 보여주는 것을 의미.
### 2. 글쓰기 페이지, 글 목록 페이지, 글 상세 페이지 등 다양한 페이지가 존재할 때 페이지 별로 컴포넌트를 분리하여 관리하기 위해서 필요한 것이 라우팅 시스템.
### 3. react에서는 react router라는 라이브러리를 이용해서 라우팅 시스템을 구축할 수 있다.
### 4. Html에서는 a태그를 이용해서 링크로 이동시켰는데 react에서는 Link태그(컴포넌트)로 링크로 이동시킨다. a태그는 페이지를 불러올 때 새로고침이 무조건 발생하기 때문이다.
### 5. Link 컴포넌트를 이용하지 않고 링크를 이동시킬 때는 useNaviget라는 Hook을 사용한다.
### 6. 링크에서 사용하는 경로가 현재 라우트 경로가 일치할 때 특정 스타일을 적용하고 싶을 때는 NavLink라는 컴포넌트를 사용한다.
### 7. 컴포넌트가 화면에 표출되는 순간 다른 페이지로 이동하려면 Navigate 컴포넌트를 사용한다. ex) 게시글 목록으로 들어왔는데 로그인이 안되어 있는 경우 로그인 페이지로 이동할 때
### 8. react router 설치: npm install react-router-dom 입력

# 1. todo app 만들기
### 1. npm install sass
### 2. npm install react-icons
### 3. npm install classnames
### 4. react-icons: react에서 사용할 수 있는 다양한 모양의 아이콘을 제공하는 라이브러리. https://react-icons.github.io/react-icons/
### 5. classnames: 나중에 조건부 스타일링하기 편한 라이브러리
### 6. TodoTemplat 컴포넌트: 화면을 가운데 정렬하여 Todo앱의 제목과 일정리스트를 표출하는 템플릿.
### 7. TodoInsert 컴포넌트: 일정을 추가하는 기능을 하는 컴포넌트.
### 8. TodoListItem: 일정 하나하나의 항목을 표출할 컴포넌트
### 9. TodoList: 일정 리스트를 표출할 컴포넌트. TodoListItem 컴포넌트를 사용하여 일정 리스트를 표출한다.
### 10. 컴포넌트의 children: pros처럼 받을 수 있는데 children 변수명으로 받아준다. children에 담기는 내용은 <컴포넌트>태그나 내용</컴포넌트> 컴포넌트 사이의 태그나 내용을 모두 받아준다.
```
const App = () => {
    return (
        <컴포넌트>
            <다른 컴포넌트>aaa</다른 컴포넌트>
            bbb
            <div>ccc</ccc>
        </컴포넌트>
    );
};

const 컴포넌트 = ({ children }) => {
    //children은 
    /*
    <다른 컴포넌트>aaa</다른 컴포넌트>
    bbb
    <div>ccc</ccc> 을 담는다.
    */
};
```
